"use strict";(globalThis.webpackChunkai_book=globalThis.webpackChunkai_book||[]).push([[154],{8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>l});var s=r(6540);const i={},a=s.createContext(i);function o(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:n},e.children)}},9085:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>t,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"Autonomous-Navigation/obstacle-avoidance-and-dynamic-environments","title":"Lesson 5: Obstacle Avoidance and Dynamic Environments","description":"Duration Unlimited | Priority Lesson 4","source":"@site/docs/04-Autonomous-Navigation/05-obstacle-avoidance-and-dynamic-environments.md","sourceDirName":"04-Autonomous-Navigation","slug":"/Autonomous-Navigation/obstacle-avoidance-and-dynamic-environments","permalink":"/docs/Autonomous-Navigation/obstacle-avoidance-and-dynamic-environments","draft":false,"unlisted":false,"editUrl":"https://github.com/your-org/ai-book/tree/main/docs/04-Autonomous-Navigation/05-obstacle-avoidance-and-dynamic-environments.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Lesson 4: Nav2 Path Planning Stack","permalink":"/docs/Autonomous-Navigation/nav2-path-planning-stack"},"next":{"title":"Lesson 6: Autonomous Humanoid Navigation","permalink":"/docs/Autonomous-Navigation/autonomous-humanoid-navigation"}}');var i=r(4848),a=r(8453);const o={},l="Lesson 5: Obstacle Avoidance and Dynamic Environments",t={},c=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Layer 1: Foundation",id:"layer-1-foundation",level:2},{value:"5.1 Static vs. Dynamic Obstacles",id:"51-static-vs-dynamic-obstacles",level:3},{value:"5.2 Costmap Inflation for Safety",id:"52-costmap-inflation-for-safety",level:3},{value:"5.3 Local Trajectory Evaluation (DWA)",id:"53-local-trajectory-evaluation-dwa",level:3},{value:"5.4 Recovery Behaviors",id:"54-recovery-behaviors",level:3},{value:"Layer 2: Collaboration (ROS 2 Integration)",id:"layer-2-collaboration-ros-2-integration",level:2},{value:"2.1 Dynamic Costmap Layers",id:"21-dynamic-costmap-layers",level:3},{value:"2.2 Dynamic Window Approach (DWA) Parameters",id:"22-dynamic-window-approach-dwa-parameters",level:3},{value:"2.3 Behavior Tree for Recovery",id:"23-behavior-tree-for-recovery",level:3},{value:"2.4 ROS 2 Services for Recovery",id:"24-ros-2-services-for-recovery",level:3},{value:"Layer 3: Intelligence (Tuning and Debugging)",id:"layer-3-intelligence-tuning-and-debugging",level:2},{value:"3.1 Obstacle Avoidance Tuning",id:"31-obstacle-avoidance-tuning",level:3},{value:"3.2 Parameter Tuning Guide",id:"32-parameter-tuning-guide",level:3},{value:"3.3 Debugging Navigation Failures",id:"33-debugging-navigation-failures",level:3},{value:"3.4 Common Failure Modes",id:"34-common-failure-modes",level:3},{value:"Layer 4: Advanced",id:"layer-4-advanced",level:2},{value:"4.1 Custom Recovery Behavior Plugin",id:"41-custom-recovery-behavior-plugin",level:3},{value:"4.2 Replanning Strategies",id:"42-replanning-strategies",level:3},{value:"Summary",id:"summary",level:2},{value:"Code Examples",id:"code-examples",level:2},{value:"Example 1: Custom Recovery Behavior",id:"example-1-custom-recovery-behavior",level:3},{value:"Example 2: Dynamic Obstacle Validator",id:"example-2-dynamic-obstacle-validator",level:3},{value:"Practice Exercise",id:"practice-exercise",level:2},{value:"References",id:"references",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"lesson-5-obstacle-avoidance-and-dynamic-environments",children:"Lesson 5: Obstacle Avoidance and Dynamic Environments"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Duration"}),": 3 hours | ",(0,i.jsx)(n.strong,{children:"Level"}),": Unlimited | ",(0,i.jsx)(n.strong,{children:"Priority"}),": P2 | ",(0,i.jsx)(n.strong,{children:"Prerequisite"}),": Lesson 4"]}),"\n",(0,i.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,i.jsx)(n.p,{children:"By the end of this lesson, you will be able to:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Implement"})," local obstacle avoidance with dynamic window approach"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Design"})," recovery behaviors for stuck detection"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Configure"})," costmap layers for real-time dynamic obstacle handling"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Tune"})," dynamic window parameters for different robot types"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Debug"})," navigation failures in constrained environments"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"layer-1-foundation",children:"Layer 1: Foundation"}),"\n",(0,i.jsx)(n.h3,{id:"51-static-vs-dynamic-obstacles",children:"5.1 Static vs. Dynamic Obstacles"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Static obstacles"}),": Permanent features in environment"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Buildings, walls, furniture"}),"\n",(0,i.jsx)(n.li,{children:"Known from map"}),"\n",(0,i.jsx)(n.li,{children:"Don't change over time"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Dynamic obstacles"}),": Temporary, moving objects"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"People, other robots, vehicles"}),"\n",(0,i.jsx)(n.li,{children:"Not in pre-built map"}),"\n",(0,i.jsx)(n.li,{children:"Change position in real-time"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Challenge"}),": Robot must avoid both simultaneously while reaching goal."]}),"\n",(0,i.jsx)(n.h3,{id:"52-costmap-inflation-for-safety",children:"5.2 Costmap Inflation for Safety"}),"\n",(0,i.jsx)(n.p,{children:"Inflation layer prevents robot from touching obstacles by expanding them:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Robot footprint: circle with radius R\r\nSafety margin: distance from robot to obstacles\r\n\r\nInflation = R + safety_margin\r\n\r\nExample:\r\nRobot radius: 0.3m\r\nSafety margin: 0.25m\r\nTotal inflation: 0.55m\r\n\r\nEffect on costmap:\r\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n     O   \u2502 Original obstacle\r\n (1.0m)  \u2502\r\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n  \u25cb \u25cb \u25cb  \u2502 Inflated region\r\n   \u25cb \u25cb   \u2502 (safety margin)\r\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"inflation_radius"}),": Total expansion distance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"cost_scaling_factor"}),": Gradient steepness","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Higher = steeper cost gradient (avoid close to obstacles)"}),"\n",(0,i.jsx)(n.li,{children:"Lower = gentler gradient (allows closer approach)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"53-local-trajectory-evaluation-dwa",children:"5.3 Local Trajectory Evaluation (DWA)"}),"\n",(0,i.jsx)(n.p,{children:"The local planner evaluates candidate trajectories:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Current state (x, y, theta, v, omega)\r\n                \u2502\r\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n    \u2502           \u2502           \u2502\r\nSample velocity pairs:\r\n(v=0.0, omega=0.0)  \u2192  Trajectory 1: goes straight\r\n(v=0.5, omega=0.0)  \u2192  Trajectory 2: accelerates\r\n(v=0.3, omega=0.5)  \u2192  Trajectory 3: curves right\r\n...\r\n\r\nFor each trajectory:\r\n\u251c\u2500 Simulate next 1 second of motion\r\n\u251c\u2500 Check collision with obstacles\r\n\u251c\u2500 Measure distance to goal\r\n\u251c\u2500 Calculate cost = obstacle_cost + goal_distance_cost\r\n\u2502\r\nSelect lowest-cost trajectory \u2192 execute first control input\n"})}),"\n",(0,i.jsx)(n.h3,{id:"54-recovery-behaviors",children:"5.4 Recovery Behaviors"}),"\n",(0,i.jsx)(n.p,{children:"When robot gets stuck, recovery behaviors attempt to escape:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Stuck detection:\r\n\u251c\u2500 Move_base_flex monitors navigation progress\r\n\u251c\u2500 If position doesn't change after T seconds \u2192 stuck\r\n\u2514\u2500 Trigger recovery behavior\r\n\r\nRecovery sequence:\r\n1. Clear local costmap (maybe sensor noise?)\r\n2. Rotate in place (360 degrees)\r\n3. If still stuck: backup 0.5m\r\n4. If still stuck: rotate again\r\n5. If still stuck: declare failure\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Why this works"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Clears spurious obstacles from sensor noise"}),"\n",(0,i.jsx)(n.li,{children:"Rotation explores alternative paths"}),"\n",(0,i.jsx)(n.li,{children:"Backup escapes local minima"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"layer-2-collaboration-ros-2-integration",children:"Layer 2: Collaboration (ROS 2 Integration)"}),"\n",(0,i.jsx)(n.h3,{id:"21-dynamic-costmap-layers",children:"2.1 Dynamic Costmap Layers"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'controller_server:\r\n  ros__parameters:\r\n    costmap:\r\n      ros__parameters:\r\n        plugins: ["static_layer", "obstacle_layer", "inflation_layer", "voxel_layer"]\r\n\r\n        static_layer:\r\n          plugin: "nav2_costmap_2d::StaticLayer"\r\n          enabled: true\r\n\r\n        obstacle_layer:\r\n          plugin: "nav2_costmap_2d::ObstacleLayer"\r\n          enabled: true\r\n          observation_sources: scan\r\n          scan:\r\n            topic: /scan  # Real-time LiDAR data\r\n            max_obstacle_height: 2.0\r\n            obstacle_max_range: 2.5\r\n            min_obstacle_height: 0.0  # Floor level\r\n            raytrace_max_range: 3.0\r\n            marking: true  # Mark obstacles\r\n            clearing: true  # Clear when no obstacle\r\n\r\n        voxel_layer:\r\n          plugin: "nav2_costmap_2d::VoxelLayer"\r\n          enabled: true\r\n          observation_sources: scan_voxel\r\n          scan_voxel:\r\n            topic: /scan\r\n            max_obstacle_height: 2.0\r\n            min_obstacle_height: 0.0\r\n            marking: true\r\n            clearing: true\r\n            decay_model: exponential  # Fade old sensor data\r\n            decay_parameter: 0.85\r\n\r\n        inflation_layer:\r\n          plugin: "nav2_costmap_2d::InflationLayer"\r\n          enabled: true\r\n          inflation_radius: 0.55\r\n          cost_scaling_factor: 10.0\r\n          inflate_unknown: false  # Don\'t inflate unknown cells\n'})}),"\n",(0,i.jsx)(n.h3,{id:"22-dynamic-window-approach-dwa-parameters",children:"2.2 Dynamic Window Approach (DWA) Parameters"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'controller_server:\r\n  ros__parameters:\r\n    plugins: ["FollowPath"]\r\n\r\n    FollowPath:\r\n      plugin: "nav2_dwb_controllers/DWBLocalPlanner"\r\n\r\n      # Simulation parameters\r\n      sim_time: 1.0  # seconds (prediction horizon)\r\n      samples_in_time: 8  # iterations for forward simulation\r\n      num_y_samples: 20  # trajectory samples\r\n      num_theta_samples: 20\r\n\r\n      # Velocity limits\r\n      min_vel_x: -0.26  # backward\r\n      max_vel_x: 0.5   # forward\r\n      max_vel_y: 0.0   # differential drive (no lateral)\r\n      max_vel_theta: 1.57  # rad/s\r\n\r\n      # Acceleration limits (ramp-up)\r\n      acc_lim_x: 2.5  # m/s\xb2\r\n      acc_lim_theta: 3.2  # rad/s\xb2\r\n\r\n      # Costs (weighted scoring)\r\n      path_distance_bias: 32.0  # Prefer paths close to reference\r\n      goal_distance_bias: 24.0  # Prefer paths toward goal\r\n      occdist_scale: 0.02  # Avoid obstacles (low weight)\r\n      forward_point_distance: 0.325  # Look-ahead distance\n'})}),"\n",(0,i.jsx)(n.h3,{id:"23-behavior-tree-for-recovery",children:"2.3 Behavior Tree for Recovery"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'\x3c!-- navigate_w_replanning_and_recovery.xml --\x3e\r\n<root main_tree_to_execute="MainTree">\r\n  <BehaviorTree ID="MainTree">\r\n    <Sequence name="main_sequence">\r\n      \x3c!-- Try to reach goal --\x3e\r\n      <FollowPath name="follow_path"\r\n                   path="{path}"\r\n                   error_code_id="follow_error"/>\r\n\r\n      \x3c!-- If failed, run recovery --\x3e\r\n      <ReactiveSequence name="recovery_sequence">\r\n        \x3c!-- 1. Clear costmap --\x3e\r\n        <ClearEntireCostmap name="clear_costmap" service_name="local_costmap/clear_entirely_local_costmap"/>\r\n\r\n        \x3c!-- 2. Try again --\x3e\r\n        <FollowPath name="follow_path_after_clear" path="{path}"/>\r\n\r\n        \x3c!-- 3. If still failing, rotate --\x3e\r\n        <Spin name="spin" service_name="spin"/>\r\n\r\n        \x3c!-- 4. Backup if rotating didn\'t help --\x3e\r\n        <BackUp name="back_up" service_name="backup" distance="0.5"/>\r\n      </ReactiveSequence>\r\n    </Sequence>\r\n  </BehaviorTree>\r\n</root>\n'})}),"\n",(0,i.jsx)(n.h3,{id:"24-ros-2-services-for-recovery",children:"2.4 ROS 2 Services for Recovery"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Service"}),(0,i.jsx)(n.th,{children:"Request"}),(0,i.jsx)(n.th,{children:"Response"}),(0,i.jsx)(n.th,{children:"Purpose"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"/clear_costmap"})}),(0,i.jsx)(n.td,{children:"-"}),(0,i.jsx)(n.td,{children:"-"}),(0,i.jsx)(n.td,{children:"Clear costmap cells"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"/spin"})}),(0,i.jsx)(n.td,{children:"max_spin_vel"}),(0,i.jsx)(n.td,{children:"Success"}),(0,i.jsx)(n.td,{children:"Rotate in place"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"/backup"})}),(0,i.jsx)(n.td,{children:"distance, speed"}),(0,i.jsx)(n.td,{children:"Success"}),(0,i.jsx)(n.td,{children:"Move backward"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"layer-3-intelligence-tuning-and-debugging",children:"Layer 3: Intelligence (Tuning and Debugging)"}),"\n",(0,i.jsx)(n.h3,{id:"31-obstacle-avoidance-tuning",children:"3.1 Obstacle Avoidance Tuning"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Scenario: Robot crashes into obstacles"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Problem: Inflation not sufficient"}),"\n",(0,i.jsxs)(n.li,{children:["Solution: Increase ",(0,i.jsx)(n.code,{children:"inflation_radius"})," or ",(0,i.jsx)(n.code,{children:"cost_scaling_factor"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Scenario: Robot stays too far from obstacles"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Problem: Overly conservative"}),"\n",(0,i.jsxs)(n.li,{children:["Solution: Decrease ",(0,i.jsx)(n.code,{children:"cost_scaling_factor"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Scenario: Jerky motions near obstacles"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Problem: DWA not smoothing trajectory"}),"\n",(0,i.jsxs)(n.li,{children:["Solution: Increase ",(0,i.jsx)(n.code,{children:"forward_point_distance"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Scenario: Robot doesn't react to dynamic obstacles"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Problem: Costmap update too slow"}),"\n",(0,i.jsxs)(n.li,{children:["Solution: Increase ",(0,i.jsx)(n.code,{children:"update_frequency"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"32-parameter-tuning-guide",children:"3.2 Parameter Tuning Guide"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Environment"}),(0,i.jsx)(n.th,{children:"Inflation"}),(0,i.jsx)(n.th,{children:"Cost Scaling"}),(0,i.jsx)(n.th,{children:"Sim Time"}),(0,i.jsx)(n.th,{children:"Recommendation"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Open space"}),(0,i.jsx)(n.td,{children:"0.3m"}),(0,i.jsx)(n.td,{children:"5.0"}),(0,i.jsx)(n.td,{children:"1.0s"}),(0,i.jsx)(n.td,{children:"Aggressive, fast"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Cluttered"}),(0,i.jsx)(n.td,{children:"0.7m"}),(0,i.jsx)(n.td,{children:"15.0"}),(0,i.jsx)(n.td,{children:"1.0s"}),(0,i.jsx)(n.td,{children:"Conservative, safe"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Narrow corridor"}),(0,i.jsx)(n.td,{children:"0.5m"}),(0,i.jsx)(n.td,{children:"20.0"}),(0,i.jsx)(n.td,{children:"0.5s"}),(0,i.jsx)(n.td,{children:"Very cautious, short horizon"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Fast navigation"}),(0,i.jsx)(n.td,{children:"0.5m"}),(0,i.jsx)(n.td,{children:"10.0"}),(0,i.jsx)(n.td,{children:"1.5s"}),(0,i.jsx)(n.td,{children:"Longer look-ahead"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"33-debugging-navigation-failures",children:"3.3 Debugging Navigation Failures"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Tool: RViz Costmap Visualization"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"View \u2192 Displays \u2192 Add \u2192 Map (costmap/costmap)\r\n\u251c\u2500 Black regions: Occupied\r\n\u251c\u2500 Gray: Unknown\r\n\u251c\u2500 White: Free\r\n\u2514\u2500 Colors between: Inflation gradient\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Tool: Nav2 Diagnostics"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Monitor planner performance\r\nros2 run rqt_plot rqt_plot /diagnostics[0]/diagnostics\r\n\r\n# Topics to monitor:\r\n# - /move_base_flex/planner/frequency (should be ~20 Hz)\r\n# - /move_base_flex/controller/frequency (should be ~100 Hz)\r\n# - /costmap/costmap_updates (should show dynamic obstacles)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"34-common-failure-modes",children:"3.4 Common Failure Modes"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Oscillation near goal"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Cause: DWA overshoots and recovers repeatedly"}),"\n",(0,i.jsxs)(n.li,{children:["Fix: Decrease ",(0,i.jsx)(n.code,{children:"max_vel_x"})," near goal"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Doesn't avoid moving obstacles"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Cause: Costmap update frequency too low"}),"\n",(0,i.jsx)(n.li,{children:"Fix: Increase to 10+ Hz"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Recovery behaviors activate too often"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Cause: Stuck detection too sensitive"}),"\n",(0,i.jsx)(n.li,{children:"Fix: Increase stuck detection timeout"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"layer-4-advanced",children:"Layer 4: Advanced"}),"\n",(0,i.jsx)(n.h3,{id:"41-custom-recovery-behavior-plugin",children:"4.1 Custom Recovery Behavior Plugin"}),"\n",(0,i.jsx)(n.p,{children:"Extend Nav2 with custom recovery action:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// custom_recovery_behavior.hpp\r\n#include "nav2_core/recovery_behavior.hpp"\r\n\r\nclass CustomRecoveryBehavior : public nav2_core::RecoveryBehavior {\r\npublic:\r\n  void onConfigure(const rclcpp_lifecycle::LifecycleNode::WeakPtr & parent,\r\n                   const std::string & plugin_name) override;\r\n\r\n  nav2_core::CancelRecoveryBehavior::SharedPtr\r\n  onRun(const std::shared_ptr<nav2_msgs::action::Spin::Goal> goal) override;\r\n};\n'})}),"\n",(0,i.jsx)(n.h3,{id:"42-replanning-strategies",children:"4.2 Replanning Strategies"}),"\n",(0,i.jsx)(n.p,{children:"When planning fails, different strategies:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"1. Replanning with increased look-ahead:\r\n   \u2514\u2500 Global planner resolves remaining goal\r\n\r\n2. Time-elastic band (TEB):\r\n   \u2514\u2500 Optimizes time and space for feasibility\r\n\r\n3. Model Predictive Control (MPC):\r\n   \u2514\u2500 Plans and controls simultaneously\r\n\r\nNav2 default: Replanning with behavior tree\n"})}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Concept"}),(0,i.jsx)(n.th,{children:"Key Insight"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Dynamic obstacles"})}),(0,i.jsx)(n.td,{children:"Handled in real-time by costmap layers"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Inflation layer"})}),(0,i.jsx)(n.td,{children:"Creates safety margins around all obstacles"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"DWA"})}),(0,i.jsx)(n.td,{children:"Evaluates multiple trajectories, selects safest"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Recovery behaviors"})}),(0,i.jsx)(n.td,{children:"Escape local minima via clear \u2192 rotate \u2192 backup"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Costmap decay"})}),(0,i.jsx)(n.td,{children:"Fade old sensor readings to prevent stale obstacles"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,i.jsx)(n.h3,{id:"example-1-custom-recovery-behavior",children:"Example 1: Custom Recovery Behavior"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# custom_recovery_behavior.py\r\nimport rclpy\r\nfrom nav2_core import RecoveryBehavior\r\nfrom geometry_msgs.msg import Twist\r\n\r\nclass RotateRecovery(RecoveryBehavior):\r\n    def __init__(self):\r\n        self.velocity_pub = None\r\n\r\n    def configure(self, node):\r\n        self.velocity_pub = node.create_publisher(Twist, \'/cmd_vel\', 10)\r\n\r\n    def execute(self):\r\n        """Execute recovery: rotate 360 degrees"""\r\n        twist = Twist()\r\n        twist.angular.z = 0.5  # rad/s\r\n\r\n        start_time = rclpy.get_clock().now()\r\n        while (rclpy.get_clock().now() - start_time).nanoseconds < 6e9:  # 6 seconds\r\n            self.velocity_pub.publish(twist)\r\n            rclpy.spin_once()\r\n\r\n        # Stop\r\n        twist.angular.z = 0.0\r\n        self.velocity_pub.publish(twist)\r\n        return True\n'})}),"\n",(0,i.jsx)(n.h3,{id:"example-2-dynamic-obstacle-validator",children:"Example 2: Dynamic Obstacle Validator"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# validate_obstacle_avoidance.py\r\nimport rclpy\r\nfrom sensor_msgs.msg import LaserScan\r\nfrom geometry_msgs.msg import PoseStamped\r\nimport math\r\n\r\nclass ObstacleAvoidanceValidator(rclpy.Node):\r\n    def __init__(self):\r\n        super().__init__('obstacle_validator')\r\n        self.create_subscription(LaserScan, '/scan', self.scan_callback, 10)\r\n        self.create_subscription(PoseStamped, '/amcl_pose', self.pose_callback, 10)\r\n\r\n        self.collision_count = 0\r\n        self.obstacle_count = 0\r\n\r\n    def scan_callback(self, msg):\r\n        \"\"\"Check LiDAR for obstacles\"\"\"\r\n        min_range = min([r for r in msg.ranges if not math.isinf(r)])\r\n\r\n        if min_range < 0.3:\r\n            self.collision_count += 1\r\n            self.get_logger().warn(f'Obstacle at {min_range:.2f}m - collision risk!')\r\n        else:\r\n            self.obstacle_count += 1\r\n\r\n    def report(self):\r\n        if self.obstacle_count > 0:\r\n            success_rate = (1 - self.collision_count /\r\n                          (self.collision_count + self.obstacle_count)) * 100\r\n            self.get_logger().info(f'Avoidance success rate: {success_rate:.1f}%')\n"})}),"\n",(0,i.jsx)(n.h2,{id:"practice-exercise",children:"Practice Exercise"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Objective"}),": Configure obstacle avoidance and test with dynamic obstacles"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Steps"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Create Gazebo world with static obstacles"}),"\n",(0,i.jsx)(n.li,{children:"Configure DWA local planner with provided YAML"}),"\n",(0,i.jsx)(n.li,{children:"Launch Nav2 with dynamic obstacle layer enabled"}),"\n",(0,i.jsx)(n.li,{children:"Move moving obstacle (using Python script) toward robot"}),"\n",(0,i.jsx)(n.li,{children:"Verify robot avoids collision"}),"\n",(0,i.jsxs)(n.li,{children:["Measure:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Distance to closest obstacle (should be >0.5m)"}),"\n",(0,i.jsx)(n.li,{children:"Time to react (<2 seconds)"}),"\n",(0,i.jsx)(n.li,{children:"Avoidance success rate (>95%)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Success criteria"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Robot successfully avoids dynamic obstacles"}),"\n",(0,i.jsx)(n.li,{children:"No collisions in 10 test scenarios"}),"\n",(0,i.jsx)(n.li,{children:"Recovery behaviors activate appropriately"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dynamic Window Approach"}),": ",(0,i.jsx)(n.a,{href:"http://mobile-robots.mybluemix.net/docs/DWAapproach.pdf",children:"The Dynamic Window Approach to Obstacle Avoidance"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Nav2 Local Planner"}),": ",(0,i.jsx)(n.a,{href:"https://navigation.ros.org/configuration/packages/configuring-dwb-controller.html",children:"DWB Controller Documentation"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Costmap Configuration"}),": ",(0,i.jsx)(n.a,{href:"https://navigation.ros.org/configuration/packages/costmap-plugins.html",children:"Costmap2D Guide"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsx)(n.p,{children:"You now understand obstacle avoidance in dynamic environments. Choose your path:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["\u2192 ",(0,i.jsx)(n.a,{href:"/docs/Autonomous-Navigation/capstone-mission",children:"Lesson 8: Capstone"})]})," (Integrate complete system)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["\u2192 ",(0,i.jsx)(n.a,{href:"/docs/Autonomous-Navigation/autonomous-humanoid-navigation",children:"Lesson 6: Humanoid Navigation"})]})," (Advanced: handle biped constraints)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["\u2192 ",(0,i.jsx)(n.a,{href:"/docs/Autonomous-Navigation/multi-sensor-perception-and-fusion",children:"Lesson 7: Sensor Fusion"})]})," (Advanced: robust perception)"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Lesson 5 Summary"}),": Obstacle avoidance combines costmap inflation for safety, dynamic window approach for trajectory evaluation, and recovery behaviors for stuck detection. Proper tuning enables robots to navigate safely through dynamic environments with people and moving objects."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);